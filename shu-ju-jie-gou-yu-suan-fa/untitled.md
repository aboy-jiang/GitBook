# 真题

## 2018

一、

1-5 ABCBD 6-10 ACBDA

二、

1. 链式存储结构 \(1\) 当多个线性表同时存在，采用链式存储结构比顺序存储结构节省空间 \(2\) 当长度动态变化，采用链式存储结构比顺序存储结构效率更高 
2. 第7层有10个叶结点的完全二叉树有两种情况： \(1\) h=7，此时结点数最少：$$2^6-1+10=73个$$	 \(2\) h=8，此时结点数最多：$$2^7-1+第8层叶结点数 = 235个$$ 第8层叶结点数 = \(第7层总结点数 - 第7层叶结点数\)\*2$$= (2^{7-1} - 10)*2 = 108$$ 
3. \(1\) 邻接矩阵中，不为0的元素的个数的一半，即为边的数组 \(2\) 邻接矩阵中，顶点对应的行中，不为0的元素的个数，即为顶点的度 \(3\) 邻接矩阵中，顶点i对应的行与顶点j对应的列相交处的元素值为1则存在边，否则不存在 
4. 因为折半插入排序中的查找过程可由“判定树”来描述，其比较次数由元素所在“判定树”的层数决定，与待排序序列的初始状态无关。 当待排序序列已经有序（升序）时，折半插入排序比直接插入排序需要进行更多元素之间比较

三、

1. 交换p指向的结点和其直接后继结点的位置 
2. 进展顺序：a1，a2，a3，a4，a5，a6 出栈顺序：a2，a3，a4，a6，a5，a1  左侧栈底 \| a1 \| a2 \|      \|    a1，a2进 \| a1 \| a3 \|      \|    a2出，a3进 \| a1 \| a4 \|      \|    a3出，a4进 \| a1 \| a5 \| a6 \|   a4出，a5，a6进 \|      \|       \|      \|    a6，a5，a1出 结论：堆栈的容量至少应该是3个元素的空间 
3.  ![](../.gitbook/assets/image%20%2828%29.png)  
4.  ![](../.gitbook/assets/image%20%2857%29.png) 深度优先遍历：ACBDE 广度优先遍历：ACEBD

四、见附件

五、

1-5 ABCBD 6-10 BCADD

六、

1

```c
int i, j, count = 0;
i = 0;
while (i < 100) {
    j = 100;
    while (j >= 2) {
        count += j - i;
        j-= 2;
    }
    i++;
}
```

2

```c
char *msg1; // 定义了一个指向char类型的指针变量，该指针变量名为msg1
char msg2[20]; // 定义个一个char类型的数组变量，该数组变量名为msg2，长度为20
在给msg1赋值时，只能赋值地址，使其指向一个 char 类型的数据。
在给msg2赋值时，不能将地址赋值给msg2，因为msg2指向的地址不可改变，但我们可以给msg2指向的数组赋值。
```

3

```c
fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
函数fread是以二进制的方式从文件中读取数据
fscanf(FILE *stream, const char *fomat, ...);
函数fscanf是以文本的方式从文件中读取数据

当数据以二进制的方式存储在文件中的时候，读取文件时可使用fread函数
当数据以文本的方式存储在文件中的时候，读取文件时可使用fscanf函数
```

4

```c
12480
```



## 2017【数据结构】

一、

1-5 DBABA 6-10 CCDDB

二、

1. 顺序
2. 链式
3. 2  ![](../.gitbook/assets/image%20%2842%29.png) 
4.  设该满K叉树深度为h，则前h-1层结点总数即为分支结点数n，即  $$n=k^0+k^1+k^2+...+k^{h-2}=\frac{k^{h-1}-1}{k-1}$$  且 $$叶结点数=k^{h-1}=n(k-1)+1$$ 
5. 中序序列
6. $$2(n-1)$$ 
7. 队列
8. 哈希（散列）查找法
9. 12次
10. 插入排序： $$O(n)$$  快速排序： $$O(n^2)$$  二路归并排序：

三、

1. 先把可能的五中结构确定，然后依次按照中序abc补充完整二叉树即可 ![](../.gitbook/assets/image%20%2884%29.png)  
2.  ![](../.gitbook/assets/image%20%2891%29.png)   ![](../.gitbook/assets/image%20%2824%29.png)  
3. 因为在不同的情况下，同一个查找算法的效率会有所不同，我们需要根据实际情况选择适当的查找算法。 （1）当查找表的长度n较小且无序时，选取顺序查找法比哈希（散列）查找法效率要高，而此时折半查找不能用，因为折半查找的前提需要查找表顺序存储且有序。 （2）当查找表的长度n较小且为顺序存储并有序时，选取折半查找法效率较高。 （3）当查找表的长度n非常大，应选取哈希（散列）查找法，虽然哈希（散列）表增加了额外的存储空间，但在n非常大的情况下可以忽略不计，并且能大大提升查找效率 
4.    ![](../.gitbook/assets/image%20%2858%29.png) 

四、见附件

五、

1-5 DCBBC 6-10 ACABD

六、

1

```c
switch(mo) {
    case : 2
        max = 28;
        break;
    case : 4
    case : 6
        max = 31;
        break;
    case : 1
    case : 3
    case : 5
        max = 30;
        break;
    default : 
        max = 0;
}
```

2

```c
三个值大小相同，因为用sizeof计算指针变量的大小，与指针变量所指向的数据的数据类型无关。
```

3.

```c

```

4

```c
FILE *fp;
char buff[100];

fp = fopen("C://tag.txt", "r");
if (pf == NULL) {
    printf("the file is empty.");
    exit(0);
}
while (fgets(buff, 100, pf) != NULL);
printf("%s\n", buff);
fclose(fp);
```

  


## 2016【数据结构】

一、

1-5 BCABD 6-10 BCD\_D

二、

1. 链式存储结构，因为插入删除操作，在顺序存储结构的线性表中需要移动多个元素效率较低，而链式存储结构的线性表只需要改变指针的指向即可 
2. 不正确  ![](../.gitbook/assets/image%20%283%29.png)  
3. 深度优先搜索，对有向图进行深度优先搜索时，如果出现某一个结点被第二次访问，则说明该有向图中存在环路 
4. 大顶堆积二叉树，任何一颗子树的左右子树的根节点的值都小于或等于该子树的根节点的值； 二叉排序树，任何一颗子树的左子树中全部结点的值都小于根节点的值，右子树中全部结点的值都大于根节点的值。 
5. 冒泡排序只需进行1趟排序，n-1次比较即可完成排序，时间复杂度为 $$O(n)$$  快速排序，当初始表中元素已经有序是，快速排序效较低，时间复杂度为 $$O(n^2)$$ 

三、

1. p-&gt;rlink = q-&gt;rlink; q-&gt;rlink-&gt;llink = p; 
2. $$n=n_0+n_m$$   $$n_m=\frac{m^{h-1}-1}{m-1}=>m^h=m[(m-1)n_m+1]$$   $$n=\frac{m^h-1}{m-1}=\frac{m[(m-1)n_m+1]-1}{m-1}$$  则有 $$n_0+n_m=\frac{m[(m-1)n_m+1]-1}{m-1} =>n_0=(m-1)n_m+1$$  
3. 当顶点数为1时，边数为0 当顶点数为2时，边数为1 设顶点数为n-1时，边数为n-2  当定点数为n时，则有n-1+1 = n-2+1，n=n-1 
4.  ![](../.gitbook/assets/image%20%28120%29.png)  
5.  13、38、49‘、27、49、76、97、65 或 13、38、27、49、76、97、65、49’



四、见附件

五、

```c
1. 
s[i] == '-'
power = 10.0*power;

2.
min = a[i];
average += min;

3.
f(n-1) + f(n-2);
i = 0; i < n; i++

4.
strcpy(book.name, "cprogram");
pbook->date.year = 2015;

5.
ch = fget(fp)
found
```

六、

1

```text
用for(;1;);或while(1);可表示一个无限循环
用break;或return;可以退出这种循环
```

2

```text
a 表示数组名
*a 表示a的第1个元素的数据的值
a[0] 表示a的第1个元素的数据的值
a+5 表示第6个元素的数据的地址
```

3

```text
argc 表示参数个数
argv 表示参数数组名
argc 为3 argv为参数数组中第1个元素的数据（tail)的地址
```

4

```text
SQR宏是在编译前的预处理过程中，对所有宏引用的地方进行字符替换，实现计算x的平方的功能。
而sqr函数是在C运行时通过对其调用，实现计算x的平方的功能。
```

## 2015【数据结构】

一、

1-5 BADCC 6-10 BADCC

二、

1. 链式
2. 普通单链表和带尾指针的单向循环链表
3. p-&gt;link = top; top = p;
4. 16
5. d, b, e, f, c, a
6. 10
7. 深度优先搜索
8. 65，15，30，37
9. 小于或等于散列表长度的最大素数
10. 快速排序

三、

1. $$log_2{\frac{n}{2}}$$ 
2.   ![](../.gitbook/assets/image%20%2861%29.png)  
3. 若无向图G中每个顶点的度至少为2，则对该图进行深度优先搜索的时候，必定会重复访问某个结点，也就是图中必定存在回路 
4. 顺序表，且有序。因为折半查找过程，需反复计算低位low和高位high的中间位置，而在链表中该计算过程比较困难，因此不能在链表中采用折半查找法

四、见附件

五、

1-5 CDAAC 6-10 \_DBAD

六、

```c
1. 
k <= n
k++

2. 
a[i-1]
a[9-i]

3.
p = s[0]
p = s[i]

4.
r != p
p + 1

5.
a[n-1]
p > a

6.
return 1
result = n + sum(n-1)

7.
-1
i

8. 
fopen(argv[1], "wb")
fout

9.
flag == 1

10.
scanf("%f", &n)
fwrite(&n, sizeof(n), 1, fp)
```

## 2014【数据结构】

一、

1. p
2. 两个堆栈的栈顶位置相遇时
3. 71
4. 前序遍历
5. 连通图
6. f, c, b
7. 8. $$\frac{n(n+1)}{2}$$ 
9. 插入排序法
10. a, d, s, b, f, l, t, w

二、

1. 输入性、输出性、有穷性、有效性、确定性 
2. 4中操作在顺序表和链表上的时间复杂度分别为： （1）$$O(1)$$和$$O(n)$$ （2）$$O(1)$$和$$O(1)$$ （3）$$O(n)$$和$$O(n)$$ （4）$$O(n)$$和$$O(n)$$ 因此（1）操作，在顺序表上实现比在链表上实现效率更高一些 
3. 由题设可得该二叉树每一层节点数为1，除根节点外每个节点可选位置数为2，故该二叉树共有 $$2^n-1$$ 种 
4. 因为当散列表中多个连续位置被占用以后，再散列到这些位置的的元素与直接散列到后面一个空闲位置的元素都要占用这一空闲位置，致使空闲位置肯容易被占用，造成更大的聚聚。采用二次探测再散列的方法可以减少这种聚集。

三、

1. 最后一个出栈元素为1的情况：321、231 最后一个出栈元素为2的情况：132 最后一个出栈元素为3的情况：123、213 
2.   ![](../.gitbook/assets/image%20%2811%29.png)  
3. 当无向图越稠密，即无向图其余顶点的度都为2时，无向图顶点数最少。设其余顶点数为x，则有： $$2*16=4*3+3*4+2x$$ 解之得x = 4，则无向图至少有3+4+4=11个。 
4. 
四、见附件

五、

1-5 DBACA 6-10 BDCAB

六、

1. 不正确，可以用数组名访问数组的第一个元素，但是数组名并不是指针变量，不能对数组名进行++操作。
2. strlen是定义在string.h中的一个函数，其功能是计算字符串的长度。sizeof是C语言中的关键字，用于计算数据类型在内存中所占字节数。
3. strcpy\(char \*s1, char \*s2\)的功能是将s2指向的字符串内容复制到s1中，使用时应注意，s1指向的地址的数据类型必须是字符串数组类型，且要注意长度不能小于s2字符串的长度，否则会出现数组溢出的问题。
4. 函数指针说的是指向函数的指针变量，可以通过指针调用函数。指针函数是一个返回类型为指针类型的函数。
5. 每次递归过程中局部变量的值

七、

```c
1. 
a[i-1]
a[9-k]

2. 
k % j == 0
break;

3.
substr[k] = '\0'
i+1

4.
*p == *q
olds++
*news = '\0'

5.
fopen("file.dat", "r")
"%d", &num
count == i
```

## 2013

一、

1-5 CADB\_ 6-10 BDA\_D

二、

1. 顺序 
2. $$O(m)$$ 
3. $$⌈log_2k⌉+1$$ `n = n0 + n1 + n2 n0 = k n1 = 0 或 1 n2 = n0 - 1 = k - 1 n = 2k - 1 或 2k 前h-1层结点总数：n - k = k - 1 或 k`    $$2^{h-1} - 1 = k - 1   或  k$$   $$h =log_2k + 1 或log_2(k+1)+1 = ⌈log_2k⌉+1$$  
4. 235或234个 
5. 2\(n-1\) 
6. 有向图中没有环路 
7. $$\frac{11}{10}log_211-1$$  
8. \_ 
9. 插入排序法 
10. 9次

三、

1. （1）多个堆栈共享同一存储空间，可以充分利用存储空间，只有在整个存储空间都用完时才能产生溢出，其缺点是当一个栈发生溢出时需要向左、右查找空闲空间，若有空间空间则需要移动和修改相应的栈顶和栈底指针，计算复杂，消耗时间。 （2）没个堆栈各用一个顺序存储空间时，操作简便。但难以确定初始分配存储空间的大小，空间分配少了容易产出溢出，空间分配多了造成空间浪费；并且各个堆栈不能共享存储空间。 （3）一般情况下，分别建立多个链式堆栈不比考虑堆栈的溢出（仅受用户内存空间限制\)，缺点是堆栈个各个元素需要通过指针链接，比顺序存储结构多占用存储空间。 
2. T-&gt;lchild == NULL && T-&gt;rchild == NULL T-&gt;lchild T-&gt;rchild 
3.  ![](../.gitbook/assets/image%20%2825%29.png)  h\(k\) = k MOD p，取p=7 $$\alpha\approx0.61$$ 

四、见附件

五、

```c
1.
break;
a/q

2.
a[2] > a[1]

3.
(p+i)
(p+N-i)

 4.
 i > 0
 i
 
 5.
 ch = ch - 'a' + 'A' + 2
 ch = ch - 'Z' - 1 + 'A'
 
 6.
 s[i]
 c[t++]
 
 7.
 strlen(p) - 1
 *p != '\0'
 
 8.


9.
2
&number

10.
argv[1], "r"
argv[2], "w"
```

六、

1. 值传递、指针传递
2. 赋值，取值，自增自减，加法
3. 共同体中的成员，可以使基本类型、结构体、共同体。共同体所占内存等于所有成员中占内存最大的那个成员所占内存。
4. 打开文件，对文件进行读写，关闭文件

## 2012【已校对】

一、

1. 数据的逻辑结构、存储结构以及在其上的操作
2. 链式存储结构
3. $$O(1)$$ 
4. 8
5. BFGDECA
6. \_
7. 子图
8. 65，15，30，37
9. $$\frac{n(n+1)}{2}$$ 
10. 1, 5, 11, 15, 19, 77,  59, 48, 26, 61

二、

1. 100个顶点的邻接矩阵，总元素数：100x100=10000个 200条边，非零元素个数：200个  $$\frac{200}{10000}=2\% < 5\%$$ ，故该邻接矩阵为稀疏矩阵 
2. 开放定址法是指将散列表中“空”地址向处理冲突开放，当散列表未满时，处理冲突需要的“下一个”空缺位置，在散列表中解决。 
3. 冒泡排序法 如果是选择排序法，第二趟排序结果为：2，5，16，18，12，10 
4. 最大：n；最小： $$⌊log_2n⌋+1$$ 

三、

1. 第4条语句错误，应该为：q-&gt;rlink-rlink-llink = p; 或 p-&gt;rlink-&gt;llink = p; 
2. 题设完全二叉树，当其深度h=8时，结点总数取得最大值 第7层结点数： $$2^{7-1}=64$$ ，非叶结点数：64-10=54个 第8层叶结点数：54x2=108个 总结点数：前7层结点数 + 第8层叶结点数 = $$2^7-1+108=235个$$  
3. 当顶点数为：1，最多边数为：0 当顶点数为：2，最多边数为：1 当顶点数为：3，最多边数为：3 设当顶点数为：n-1，最多边数为： $$\frac{(n-1)(n-2)}{2}$$  则当顶点数为：n+1-1，最多边数为：$$\frac{(n+1-1)(n+1-2)}{2}$$，即 当顶点数为：n，最多边数为：$$\frac{n(n-1)}{2}$$ 
4.    ![](../.gitbook/assets/image%20%28125%29.png)

    

四、见附件

五、

1-5 CDAC_**B**_    6-10 DADBA

六、

1. （1）通过头文件来调用函数库。在很多场合，源代码不便（或不准）向用户公布，只给用户提供头文件和二进制库即可。用户需要按照头文件中声明的接口来调用库功能，而不必关心接口怎样实现的。编译器会从库中提取相应的代码。 （2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。 
2. 二者都是引用头文件filename.h，不同的是\#include "filename.h"是从当前文件目录查找filename.h文件，一般用户自定义的文件使用该方式引用；而\#include &lt;filename.h&gt;是从系统环境变量中查找filename.h文件，一般系统库文件使用该方式引用。 
3. 全局变量可在程序的任何位置使用，在程序运行前系统就为其分配好了内存空间；局部变量只能在定义的局部使用，在程序执行到该局部变量定义处时，在为其分配内存空间。 
4. 一样大，因为指针变量在内存中所占内存的大小和指针指向的具体类型无关，而是和编译器有关。要求能表示出程序中所用到的最大内存地址，一般占一个机器字长。

七、

```c
1.
50 x

2.
-f (或 i % 2 == 0 ? 1 : -1)
2 * i + 1 

3.
c += 5
c = 'a' + c + 5 - 'z' - 1 (或 c = c - 21)

4. 
*t
*s - *t

5.
str3[k] = str2[j++]
str2[j] != '\0'

6.
argc > 1
*argv

7.
a+
r
fp2
fgetc(fp2)

8.
计算整数n的位数

9.
读取用户输入的字符串，并且判断字符串是否为回文

10.
在文件末尾追加“data”字符串，并且打印追加后文件指针的位置

```



## 2011

一、

1-5 DCABB 6-10 DCAAC

二、

1. 插入： $$\frac{n}{2}$$  删除： $$\frac{n+1}{2}$$ 表的长度、插入或删除位置 
2. 只设置一个队尾指针，时间效率要高。 只设置一个队尾指针，队尾指针的“下一个”结点即为队头指针，入队和出队的时间复杂度为 $$O(1)$$  只设置一个队头指针，要想找到队尾指针需要遍历整个队列，入队和出队的时间复杂度为$$O(n)$$ 
3. 稀疏图采用邻接表存储，稠密图采用邻接矩阵存储 邻接表存储，是用一个1维数组存储顶点信息，一个2维数组存储边信息 邻接矩阵存储，是用一个2维数组存储所有顶点之间的是边信息，有边有1，无边为0 若稀疏图采用邻接矩阵存储，会造成较大空间的浪费 若稠密图采用邻接表存储，其在空间上除了存储边信息外，还需存储顶点信息，空间开销会更大 
4. 小顶堆积：二叉树本身或任何一个子树其根结点元素值，都小于或等于其左右子结点元素的值，例如序列10，20，30，40，50，60、70的小顶堆积如下：  ![](../.gitbook/assets/image%20%2883%29.png)  最大元素可能处于任何一个叶结点中

三、

1. k=j+1; k&lt;n; k++ j++; i++; 
2. \_ 
3. \_ 
4.   ![](../.gitbook/assets/image%20%2855%29.png) 

四、见附件

五、

```c
1.
65 B

2.
8

3.
4332

4.
11

5.
2

6.
354

7.
Y=7

8.
9

9.
12

10.
IF YOU FAIL TO PL
```

六、

```c
1.
0 < x < y

2.
3 12 6.0

3.
m % 5 == 0

4.
num = *b
num = *c

5.
fname, "w+"
ch, fp
fp, "%s", date
```

## 2010

一、

1-5 CAADB 6-10 DACDA

二、

1. $$p_i*\sum_{i=1}^{n+1}i=\frac{2(n-i+1)}{n(n+1)}*\frac{n(n+1)}{2}=\frac{2(n-i+1)}{2}$$  
2. 方法中通过直接或间接调用自己的过程，称为递归调用。用该方法描述的算法，即为递归算法。递归算法需要借用栈的结构来完成。 
3. 遍历起始位置、遍历方法是深度优先搜索还是广度优先搜索、图的存储结构 
4. 堆积排序 题设条件下，设n=10000，m=10，则 选择排序的时间复杂度为： $$O(mn)$$  快速排序的时间复杂度为：$$O(nlog_2n)$$ 堆积排序的时间复杂度为：$$O()$$

三、

1.  ![](../.gitbook/assets/image%20%2827%29.png)  拓扑排序： ABCFED ABFCED 
2.   ![](../.gitbook/assets/image%20%2845%29.png)  
3.   ![](../.gitbook/assets/image%20%28109%29.png)  
4. 查找整形数组中的最大值

四、见附件

五、

1-5 BCACD    6-10 ABBDC    11-15 CBADC    16-20 B_**D**_CDC

六、

```c
1.
0,1

2.
5

3.
11 7

4.
1 2
```





## 2008

一、

1. 顺序存储结构：内存中存储数据的地址必须连续，可用存储结构表示其逻辑结构，通常用数组这一结构表示 链式存储结构：内存中存储数据的地址不一定连续，没个存储结点除了存储数据外，还需要用一个指针标识其下一个结点，来标示其逻辑结构。 
2. CDEBA、CDBEA、CDBAE 
3. 需比较关键字：20、12、21、34  ![](../.gitbook/assets/image%20%2892%29.png)  
4. 
二、

1. p-&gt;llink-&gt;rlink=p 
2. $$n=n_0+n_2$$  $$n=1+2n_2$$  $$n_2=n_0-1$$  $$分支数=2*n_2=2(n_0-1)$$  
3.   ![](../.gitbook/assets/image%20%28116%29.png)  拓扑排序： v1, v2, v3, v4, v5 v1, v3, v4, v2, v5 v1, v3, v2, v4, v5 
4. \_

三、见附件

四、见附件

五、

1-5 ABCBC    6-10 ACDAD

六、

1. 非0
2. 0
3. 123.460000
4. 3和5
5. 880
6. 4
7. 1  -2  
8. &lt;空格字符&gt;&lt;空格字符&gt;1&lt;空格字符&gt;&lt;空格字符&gt;-2
9. 5
10. &gt;0





## 2007

一、

1-5 DCBAD 6-10 B\_C\_C 

二、

1. 顺序存储结构，因为顺序存储结构的线性表存储元素的时间复杂度为 $$O(1)$$  
2. \_ 
3. 选择插入排序 插入排序：13次 冒泡排序：17次

三、

1. 计算单链表中的的结点总数 
2. abc全排列：abc、acb、bac、bca、cab、cba 可能出栈序列： abc：PUSH, POP, PUSH,POP, PUSH, POP acb：PUSH, POP, PUSH, PUSH, POP, POP  bac：PUSH, PUSH, POP, POP, PUSH, POP bca：PUSH, PUSH, POP, PUSH, POP, POP cba：PUSH, PUSH, PUSH, POP, POP, POP 不可能出栈序列： cab 
3.  ![](../.gitbook/assets/image%20%28124%29.png) ![](../.gitbook/assets/image%20%2818%29.png)  \_构造最小生成树\_

四、见附件

五、见附件

六、

1-5 ABDAC    6-10 DDAAD    11-15 BBCAB     16-20 ACBDD

七、

1. 结构化程序设计语言特点
2. 文件类型的指针即FILE类型的指针，
3. puts\(\)和printf\(\)函数，都是将数据输入到标准输出文件stdout上（即在控制台显示），puts\(\)只能输出字符串，printf\(\)除了可以输出字符串，还可以输出多种类型数据。

## 2006

一、

1. $$O(1)$$ 
2. 链式
3. b, c, e, d, a
4. $$\frac{n+1}{2}$$ 
5. 6. 113
7. 5
8. 3
9. $$\frac{n(n-1)}{2}$$ 
10. 59, 45, 26, 15, 19, 11, 1, 5, 61, 77

二、

1. 不是， 
2. 
三、

四、见附件

五、见附件

六、

1-5 ADABD    6-10 AABDB    11-15 CBCAC    16-20 BABCD

七、

1. 递归程序是在程序执行中，有函数自己直接或间接的调用了自己的程序，反之成为非递归程序。递归程序比非递归程序逻辑清晰，表达简单，容易理解，但是递归过程中需要存储递归函数中的临时变量，很耗费空间，且递归的多次函数调用比较耗费时间、性能。
2. 系统库函数和用户自定义函数

## 2005

一、

1-5 CDDAC 6-10 BBDBC

二、

1. 顺序存储结构、链式存储结构、索引存储结构、哈希（散列）存储结构
2. $$O(1)$$ 
3. 1+LENGTH\(list-&gt;link\)
4. p = lista; p-&gt;link != NULL; p = p-&gt;link
5. top--
6. 索引二叉树
7. 求矩阵第i列中不为0的元素的个数
8. 5, 8, 6, 7
9. 选择排序
10. 77, 61, 59, 15, 5, 14, 26, 1

三、

![](../.gitbook/assets/image%20%2823%29.png) 

四、

![](../.gitbook/assets/image%20%2840%29.png)

五、见附件

六、

1-5 DADCB     6-10 AACDD

